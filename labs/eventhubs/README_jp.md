# イベントハブ

イベントハブは、大規模なイベントの発行を目的としたメッセージングサービスです。一日に数百万、月に数十億という規模のイベントが発行されます。イベントとは、実質的にはメッセージと同じですが、意図が異なります。メッセージは何かを行うように求めるコマンドであったり、応答を期待する要求であることが多いです。一方、イベントは何かが起こったという記録に過ぎず、消費者は聞くべきイベントの種類とそれが起こった時にどうするかを決定します。

このラボではイベントハブの使用を開始し、イベントのストリームとして入ってくるデータを扱う方法を見ていきます。

## 参照

- [イベントハブ概要](https://learn.microsoft.com/ja-jp/azure/event-hubs/event-hubs-about)

- [スケーラビリティとスループットユニット](https://learn.microsoft.com/ja-jp/azure/event-hubs/event-hubs-scalability)

- [`az eventhubs` コマンド](https://learn.microsoft.com/ja-jp/cli/azure/eventhubs?view=azure-cli-latest)

## イベントハブ名前空間 & ハブの作成

ポータルで新しいリソースを作成し、'event hub' を検索します。作成をクリックしオプションを探索します：

- ハブには名前空間名があり、これは `.servicebus.windows.net` のようなサービスバスの概念と同じです。
- 料金体系は消費ベースで、入力イベントは百万単位です。
- スループットユニット - メッセージング容量とスケールを定義します。

_イングレス_ はプロデューサーからイベントハブへの入ってくるメッセージを指します。

CLIに切り替えてRGとイベントハブ名前空間を作成します：



```
az group create -n labs-eventhubs --tags courselabs=azure -l southeastasia

# TLSと容量を設定して名前空間を作成：
az eventhubs namespace create --min-tls 1.2 --capacity 2  --sku Basic -g labs-eventhubs -l southeastasia -n <eh-name> 
```


ポータルで名前空間を開き、イベントハブ名前空間を参照します：

- コマンドの容量は何を参照していますか？
- イベントの送受信に認証するにはどうすればいいですか？

名前空間の _イベントハブ_ タブを開き、新しいものを作成するためのオプションを見てみます：

- `パーティション`はイベントハブの重要な概念で、スケーラビリティに直接影響を与えます。
- メッセージの保持期間は、プレミアム層で最大90日まで設定できます。

_パーティション_ は受信メッセージストリームを分割し、大規模で実行するためのより大きな容量を提供します。パーティションが多ければ多いほど、より多くの同時実行、生産者、消費者が同時に実行され、同じハブで作業することができます。

## イベントハブの作成とイベントの発行

名前空間はグルーピングメカニズムです。実際のイベントハブを作成して送受信する必要があります。

📋 3つのパーティションと1日の保持期間を持つ `devicelogs` というイベントハブを作成します。

<details>
  <summary>わからない場合は？</summary>

ヘルプをチェック：



```
az eventhubs eventhub create --help
```


設定されたパーティションと保持期間でイベントハブを作成：



```
az eventhubs eventhub create --name devicelogs --partition-count 3 --message-retention 1 -g labs-eventhubs --namespace-name <eh-name>
```


</details><br/>

新しいイベントハブをポータルで開くと、データのキャプチャと処理に関するオプションが表示されます。イベントハブはカスタムコードでイベントを処理することができますし、自動的にAzureデータと分析サービスに取り込むこともできます。

イベントハブでのコード作業はサービスバスの使用に似ています。これは単純なアプリケーションで、イベントを発行します：

- [producer/Program.cs](/src/eventhubs/producer/Program.cs) - イベントは常にバッチで送信され、イベントコンテンツ自体は単なるバイト配列です。このコードはオブジェクトをJSONにシリアライズし、ライブラリはJSON文字列からバイトを生成します。

イベントハブ接続はサービスバスと同じアクセスポリシー概念を使用し、名前空間は同じデフォルト管理ポリシー名 `RootManageSharedAccessKey` で作成されます。

📋 ルート認証規則を使用するための接続文字列を印刷します。

<details>
  <summary>わからない場合は？</summary>



```
az eventhubs namespace authorization-rule keys list -n RootManageSharedAccessKey --query primaryConnectionString -o tsv -g labs-eventhubs --namespace-name <eh-name>
```


</details><br/>

プロデューサーをローカルで実行します（[.NET 6 SDK](https://dotnet.microsoft.com/ja-jp/download)が必要です）、イベントハブにメッセージを公開します：


```
# 接続文字列を 'quote' します：
dotnet run --project src/eventhubs/producer -cs '<connection-string>'
```


10人の異なるプロデューサーがそれぞれ10メッセージのバッチを送信し、その後プログラムは終了します。

ポータルでトラフィックが表示されるか確認してください。

## ストリーム分析でイベントをプレビュー

イベントハブは管理されたデータ処理オプションが付いているため、標準的なシナリオでは消費者コードを書く必要がないかもしれません。_データ処理_ タブを開きます：

- _ストリーム分析クエリ言語を使用してイベントハブデータを処理する_ の下で _開始_ をクリックします。
- シンプルなSQLライクなクエリが開くプレビューウィンドウが開きます。
- _作成_ ボタンをクリックして、クエリからイベントハブへの接続を設定します。
- イベントがプレビューウィンドウに読み込まれます。

再びプロデューサーを実行して、クエリをリフレッシュしてさらにイベントを表示します。イベントが表示されるまでに時間がかかることがあります。プレビューテーブルには、公開されたイベントのすべてのフィールドと、イベントハブによって追加されたいくつかのフィールド（EventProcessedTime、PartitionIdなど）が表示されます。

> ストリーム分析を使用すると、コードを書かずにイベントを収集、フィルタリング、保存することができます。

最初のイベント時間をメモしてください。クエリエディタを終了し、もう一度ロードします - 同じイベントが表示されますか？

> はい。イベントはイベントハブで期限切れになるまで保持されます。消費者はどこまで遡って読むかを選ぶことができます。

## コンシューマグループからイベントを受信

イベントハブはサービスバスキューまたはトピックと少し似ているかもしれませんが、動作は全く異なります。サービスバスは処理済みのメッセージを追跡し、消費者が完了したとマークしたときにそれらを削除します。イベントハブはすべてのメッセージを期限が切れるまで保持し、ハブからイベントを削除する概念はありません。

代わりに消費者は処理したイベントを記録する責任があります。停止して再起動する場合、どこから再開するかを知る必要があります。これにより、イベントが大量に生成されても、一度もイベントを逃さずに高い信頼性の処理システムを構築するためのインフラが提供されます。

しかし、少し複雑なので、もっとシンプルなものから始めましょう：

- [consumer/Program.cs](/src/eventhubs/consumer/Program.cs) - イベントハブに接続し、50イベントを読み、いくつかの詳細を印刷し、そして終了します。

このアプリケーションは高いスケールでの処理には適していませんが、私たちの例アプリには十分です。プロデューサーと同じ接続文字列で実行できます：


```
# 消費者を実行します：
dotnet run --project ./src/eventhubs/consumer -cs '<connection-string>'
```


> 異なるパーティションからのイベントが読み取られていることが見られるかもしれません。これはイベントを受け取る際の論理を持たないシンプルな消費者です。

何度か消費者を実行すると、異なるパーティションからのイベントが表示されます。実行を続けると、同じイベントが繰り返し読み取られます：


```
dotnet run --project ./src/eventhubs/consumer -cs '<connection-string>'
```

コンシューマコードは、イベントストリームからある程度ランダムに50のイベントを引っ張っています。これまでに処理した記録を保持していないため、実行するたびに再びランダムに50のイベントを引っ張ります。これには、既に処理したイベントも含まれる可能性があります。

## ラボ

コンシューマはメッセージに関するさらなる情報を出力します - これには _パーティション_ と _オフセット_ が含まれます。これら二つのデータにより、スケールに応じた信頼性のある処理が可能となり、イベントが少なくとも一度は処理されることを保証します。これらのデータをどのように使用して、同時に実行可能で再起動しても同じイベントを繰り返し取得しない複数のコンシューマを構築できるでしょうか？

> 詰まっていますか？ [ヒント](hints_jp.md)を試すか、[解答](solution_jp.md)を確認してください。

___

## クリーンアップ

ラボのリソースグループを削除します：



```
az group delete -y --no-wait -n labs-eventhubs
```
