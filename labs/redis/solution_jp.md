# ラボの解決策

## Pub-sub メッセージング

1つのCLIサブスクライバーから始めて、キューでリスニングしているものが何もない状態でそれを終了させます。その後、新しい`-dp`値でPiアプリを数回実行し、データをRedisに保存し、イベントを公開します。

アプリは同じ方法で動作し、サブスクライバーがいなくても失敗しません。

次に、Redis CLIでイベントを再度購読します：



```
SUBSCRIBE events.pi.computed
```


> 何もありません。Redisはサブスクライバーがいない場合、メッセージを保存しません。

Service Busの場合とは異なり、メッセージが公開されたときにキューを聴いているものが何もない場合、それらは永遠に失われます。

新しいブラウザウィンドウでRedis CLIを開いて再度購読してみてください：



```
SUBSCRIBE events.pi.computed
```


新しい`-dp`値でPiアプリをさらに数回実行し、コンソールに戻って確認します。各サブスクライバーがメッセージのコピーを受け取ることがわかります。

> これもService Busとは異なります - 複数のサブスクライバーがキューに対してある場合、メッセージはそれらの間で共有されます。

Redisはpub-subメッセージングのみを提供し、すべてのサブスクライバーがメッセージのコピーを受け取ります。スケールをサポートするためにサブスクライバーの複数インスタンスを実行する場合、処理が重複しないようにコード内でワークロードを管理する必要があります。

## キャッシュのクリア

AzureでのRedisインスタンスのホームページで、Redisのメモリ使用量を見ることができます。キャッシュされたPi結果にはごくわずかな量ですが、Redisを広範囲に使用する場合は、パフォーマンステスト中にこれを追跡したいでしょう。

キャッシュを完全にクリアする必要がある場合は、CLIでflushコマンドを使用して行うことができます：



```
FLUSHDB
```


それで全てが削除されます（いくつかの`GET`コマンドを使って確認してみてください）。しかし、キャッシュはまだ動作しているので、Piアプリを再度実行すると新しいアイテムが挿入されます。
