# プロジェクト 3: コンテナ化されたアプリケーション

これらのプロジェクトは、Azureで専念して設計およびデプロイする自分自身のソリューションに取り組むチャンスです。

あなたは学んだすべての主要なスキルを使用し、以下のことを行います:

- 😣 行き詰まることがあります
- 💥 エラーや壊れたアプリが発生します
- 📑 研究とトラブルシューティングが必要になります

**だからこそ、プロジェクトはとても役立ちます！**

どの領域が得意で、どこにもっと時間をかける必要があるかを理解するのに役立ちます。

この第三のプロジェクトは、_コンテナ化されたアプリケーション_です。これは、コンテナで実行するように設計されたアプリケーションです。このアプリは、同じアーキテクチャを使用しているが、異なるテクノロジーを使用している [プロジェクト 2](/projects/distributed/README.md) の進化版であり、クラウドや他の環境間で移植可能なソリューションです。

## アプリケーションアーキテクチャ

アプリケーションのUIは同じです:

![プロジェクト 3 アプリ](/img/project-1-app.png)

このアプリのバージョンは [プロジェクト 2]() と同じ分散アーキテクチャを持っていますが、メッセージキューはAzure Service BusからRedisに変更されています:

![プロジェクト 3 アーキテクチャ](/img/project-3-arch.png)

- ユーザー向けのWebアプリケーション（.NET 6）
- トランザクションデータベース（SQL Server）
- メッセージキュー（Redis）
- メッセージハンドラー（.NET 6）
- 集中ログ用のドキュメントデータベース（Azure Table Storage）

Redisを使用することで、アプリケーションをより移植可能にします。すべてのコンポーネントはコンテナで実行されるか、またはインフラコンポーネント（データベース、メッセージキュー、テーブルストレージ）は管理されたサービスで実行できます。

## 🥅 目標

アプリをAKSで実行することが目標です。

すでにコンテナを使用して動作するアプリのバージョンがありますが、Docker Composeでモデル化されています。Compose実装には、Kubernetesモデルを構築するために必要なすべての情報が含まれています。

アプリがローカルでモデル化され実行されたら、さらに3つの段階があります:

1. AKSで開発環境を実行します。すべてのコンポーネントにコンテナを使用します。
2. AKSで本番環境を実行します。インフラコンポーネントにAzureサービスを使用します。
3. 本番Azureデプロイメントをセキュアにします。インフラサービスはAKSからのみ使用できますようにします。

アプリケーションには完全自動化されたデプロイメントが必要です。

**このプロジェクトには多くの作業がありますが、どれだけ進められたかは良い成果です。**

## 覚えておくこと...

_探索 | デプロイ | 自動化_

正しくモデル化され結線された多くのコンポーネントがあります。AKSに移行する前に、KubernetesでローカルにDocker Desktopでアプリを完全に実行することが賢明です。

## 開発環境

このバージョンのアプリをローカルで実行するためには、Azureリソースは必要ありません。

[docker-compose.yml](/projects/containerized/docker-compose.yml) - Dockerを使用してアプリを実行するためのモデル:

- WebアプリケーションとメッセージハンドラーのためのDocker Hubからのイメージ
- メッセージングのための公式Redisイメージ
- データベースのための軽量SQL Serverイメージ
- テーブルストレージのための [Azurite](https://learn.microsoft.com/ja-jp/azure/storage/common/storage-use-azurite?tabs=docker-hub) ストレージアカウントエミュレータ


```
# プロジェクトのルートに移動:
cd projects/containerized

# アプリを実行:
docker compose up -d
```

http://localhost:8099 にアクセスします。To-Do ウェブサイトが表示されたら、新しいアイテムを追加してください。

---
🤔 **リストに新しいアイテムが表示されない場合** 😟

バックグラウンドでアイテムは追加されており、ハンドラーがメッセージを受け取って新しいデータを挿入する前に、ウェブページはリストを読み込みます。リストを更新すると、新しいアイテムが表示されるはずです。

---

ログはローカルのテーブルストレージエミュレータに保存されています。それらを見たい場合は、[Storage Explorer](https://learn.microsoft.com/en-us/azure/vs-azure-tools-storage-manage-with-storage-explorer) をダウンロードしてローカル開発ストレージに接続できます。

## 設定

アプリケーションは標準的な .NET 設定モデルを使用しています。デフォルト設定は [web/appsettings.json](/projects/containerized/src/web/appsettings.json) および [save-handler/appsettings.json](/projects/containerized/src/save-handler/appsettings.json) にあります。**これらのファイルは変更しないでください**。これらは開発時に実行するための正しい設定がされており、ソースコードリポジトリで求められるものです。

Azure にデプロイする際は、Compose モデルで設定したのと同じ設定項目を設定する必要があります。Compose はこの設定ファイル [docker/config.json](/projects/containerized/docker/config.json) を使用しますが、Kubernetes でのモデルは異なる必要があります。

## ソースコード

Docker Hub 上のコンテナイメージからデプロイするため、アプリケーションをコンパイルしたり、自分でイメージをビルドする必要はありません。参考までに、アプリのコードはこのリポジトリにあります：

- `projects/containerized/src` - ウェブアプリ、メッセージハンドラー、共有ライブラリの .NET ソースコード
- `projects/containerized/docker` - ウェブアプリとメッセージハンドラーの Dockerfile

## ストレッチ

このバージョンのアプリには、KeyVault から構成データを読み取るロジックがありませんが、KeyVault のシークレットをコンテナにマウントする AKS セットアップを使用できます。

デプロイメントスクリプトを拡張して、KeyVault に接続文字列を設定し、そこからコンテナ構成に値を読み込むようにします。
